import { Sequelize, DataTypes, Op } from 'sequelize';

/**
 * ÿ•ÿµŸÑÿßÿ≠ ŸÖÿ¥ÿßŸÉŸÑ enum ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
 * Fix enum issues in database
 */

console.log('üîß ÿ®ÿØÿ° ÿ•ÿµŸÑÿßÿ≠ ŸÖÿ¥ÿßŸÉŸÑ enum...\n');

// ÿ•ÿπÿØÿßÿØ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
const DATABASE_URL = 'postgres://postgres:XIclgABy2kg3ZZ2Nyh7GOYexxcm206RTNsSAJavhbF4ukgMfDiNqXSOhy8SIALUP@72.60.92.146:5432/golden-horse-shipping';

const sequelize = new Sequelize(DATABASE_URL, {
  dialect: 'postgres',
  logging: false,
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

async function fixEnumIssues() {
  try {
    console.log('üìä ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™...');
    await sequelize.authenticate();
    console.log('‚úÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÜÿßÿ¨ÿ≠\n');

    // 1. ŸÅÿ≠ÿµ enum types ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ©
    console.log('üîç ŸÅÿ≠ÿµ enum types ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ©...');
    try {
      const enumTypes = await sequelize.query(`
        SELECT t.typname, e.enumlabel
        FROM pg_type t 
        JOIN pg_enum e ON t.oid = e.enumtypid  
        WHERE t.typname LIKE '%enum%'
        ORDER BY t.typname, e.enumsortorder
      `, { type: sequelize.QueryTypes.SELECT });
      
      console.log('üìã enum types ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ©:');
      const groupedEnums = {};
      enumTypes.forEach(row => {
        if (!groupedEnums[row.typname]) {
          groupedEnums[row.typname] = [];
        }
        groupedEnums[row.typname].push(row.enumlabel);
      });
      
      Object.keys(groupedEnums).forEach(typeName => {
        console.log(`  - ${typeName}: [${groupedEnums[typeName].join(', ')}]`);
      });
      
    } catch (error) {
      console.log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ≠ÿµ enum types: ${error.message}`);
    }

    // 2. ÿ•ÿµŸÑÿßÿ≠ Sales Invoices functions ŸÖÿπ enum casting
    console.log('\nüîß ÿ•ÿµŸÑÿßÿ≠ Sales Invoices functions ŸÖÿπ enum casting...');
    try {
      const salesInvoicesFunction = `
        CREATE OR REPLACE FUNCTION get_sales_invoices_fixed(
          page_num INTEGER DEFAULT 1,
          page_size INTEGER DEFAULT 10,
          search_term TEXT DEFAULT NULL,
          status_filter TEXT DEFAULT NULL,
          customer_filter UUID DEFAULT NULL
        )
        RETURNS JSON AS $$
        DECLARE
          result JSON;
          total_count INTEGER;
          offset_val INTEGER;
        BEGIN
          offset_val := (page_num - 1) * page_size;
          
          -- Get total count
          SELECT COUNT(*) INTO total_count
          FROM sales_invoices si
          LEFT JOIN customers c ON si."customerId" = c.id
          WHERE si."isActive" = true
            AND (search_term IS NULL OR si."invoiceNumber" ILIKE '%' || search_term || '%')
            AND (status_filter IS NULL OR si.status::text = status_filter)
            AND (customer_filter IS NULL OR si."customerId" = customer_filter);
          
          -- Get data
          SELECT json_build_object(
            'data', json_agg(
              json_build_object(
                'id', si.id,
                'invoiceNumber', si."invoiceNumber",
                'invoiceDate', si."invoiceDate",
                'dueDate', si."dueDate",
                'totalAmount', si."totalAmount",
                'status', si.status::text,
                'paymentStatus', si."paymentStatus"::text,
                'salesPerson', si."salesPerson",
                'salesChannel', si."salesChannel",
                'notes', si.notes,
                'createdAt', si."createdAt",
                'customer', json_build_object(
                  'id', c.id,
                  'code', c.code,
                  'name', c.name,
                  'phone', c.phone,
                  'email', c.email,
                  'type', c.type::text
                )
              )
            ),
            'pagination', json_build_object(
              'total', total_count,
              'page', page_num,
              'limit', page_size,
              'totalPages', CEIL(total_count::FLOAT / page_size)
            )
          ) INTO result
          FROM sales_invoices si
          LEFT JOIN customers c ON si."customerId" = c.id
          WHERE si."isActive" = true
            AND (search_term IS NULL OR si."invoiceNumber" ILIKE '%' || search_term || '%')
            AND (status_filter IS NULL OR si.status::text = status_filter)
            AND (customer_filter IS NULL OR si."customerId" = customer_filter)
          ORDER BY si."invoiceDate" DESC
          LIMIT page_size OFFSET offset_val;
          
          RETURN result;
        END;
        $$ LANGUAGE plpgsql;
      `;
      
      await sequelize.query(salesInvoicesFunction);
      console.log('‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° get_sales_invoices_fixed function');
      
      // ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÄ function
      const invoicesTest = await sequelize.query(`
        SELECT get_sales_invoices_fixed(1, 5) as invoices
      `, { type: sequelize.QueryTypes.SELECT });
      
      const invoicesData = invoicesTest[0].invoices;
      console.log(`‚úÖ ÿßÿÆÿ™ÿ®ÿßÿ± get_sales_invoices_fixed ŸÜÿ¨ÿ≠: ${invoicesData.data?.length || 0} ŸÅÿßÿ™Ÿàÿ±ÿ©`);
      
    } catch (error) {
      console.log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿµŸÑÿßÿ≠ Sales Invoices function: ${error.message}`);
    }

    // 3. ÿ•ÿµŸÑÿßÿ≠ Customers function ŸÖÿπ enum casting
    console.log('\nüë• ÿ•ÿµŸÑÿßÿ≠ Customers function ŸÖÿπ enum casting...');
    try {
      const customersFunction = `
        CREATE OR REPLACE FUNCTION get_customers_list_fixed(
          page_num INTEGER DEFAULT 1,
          page_size INTEGER DEFAULT 10,
          search_term TEXT DEFAULT NULL,
          type_filter TEXT DEFAULT NULL
        )
        RETURNS JSON AS $$
        DECLARE
          result JSON;
          total_count INTEGER;
          offset_val INTEGER;
        BEGIN
          offset_val := (page_num - 1) * page_size;
          
          -- Get total count
          SELECT COUNT(*) INTO total_count
          FROM customers c
          WHERE c."isActive" = true
            AND (search_term IS NULL OR c.name ILIKE '%' || search_term || '%' OR c.code ILIKE '%' || search_term || '%')
            AND (type_filter IS NULL OR c.type::text = type_filter);
          
          -- Get data
          SELECT json_build_object(
            'data', json_agg(
              json_build_object(
                'id', c.id,
                'code', c.code,
                'name', c.name,
                'phone', c.phone,
                'email', c.email,
                'balance', c.balance,
                'type', c.type::text,
                'customerType', c."customerType"::text,
                'creditLimit', c."creditLimit",
                'paymentTerms', c."paymentTerms",
                'isActive', c."isActive",
                'createdAt', c."createdAt"
              )
            ),
            'pagination', json_build_object(
              'total', total_count,
              'page', page_num,
              'limit', page_size,
              'totalPages', CEIL(total_count::FLOAT / page_size)
            )
          ) INTO result
          FROM customers c
          WHERE c."isActive" = true
            AND (search_term IS NULL OR c.name ILIKE '%' || search_term || '%' OR c.code ILIKE '%' || search_term || '%')
            AND (type_filter IS NULL OR c.type::text = type_filter)
          ORDER BY c.name
          LIMIT page_size OFFSET offset_val;
          
          RETURN result;
        END;
        $$ LANGUAGE plpgsql;
      `;
      
      await sequelize.query(customersFunction);
      console.log('‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° get_customers_list_fixed function');
      
      // ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÄ function
      const customersTest = await sequelize.query(`
        SELECT get_customers_list_fixed(1, 5) as customers
      `, { type: sequelize.QueryTypes.SELECT });
      
      const customersData = customersTest[0].customers;
      console.log(`‚úÖ ÿßÿÆÿ™ÿ®ÿßÿ± get_customers_list_fixed ŸÜÿ¨ÿ≠: ${customersData.data?.length || 0} ÿπŸÖŸäŸÑ`);
      
    } catch (error) {
      console.log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿµŸÑÿßÿ≠ Customers function: ${error.message}`);
    }

    // 4. ÿ•ŸÜÿ¥ÿßÿ° helper functions ŸÑŸÑŸÄ APIs
    console.log('\nüõ†Ô∏è ÿ•ŸÜÿ¥ÿßÿ° helper functions ŸÑŸÑŸÄ APIs...');
    try {
      const helperFunctions = `
        -- Helper function ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ customer ÿ®ŸÄ ID
        CREATE OR REPLACE FUNCTION get_customer_by_id(customer_id UUID)
        RETURNS JSON AS $$
        DECLARE
          result JSON;
        BEGIN
          SELECT json_build_object(
            'id', c.id,
            'code', c.code,
            'name', c.name,
            'phone', c.phone,
            'email', c.email,
            'balance', c.balance,
            'type', c.type::text,
            'customerType', c."customerType"::text,
            'creditLimit', c."creditLimit",
            'paymentTerms', c."paymentTerms",
            'isActive', c."isActive"
          ) INTO result
          FROM customers c
          WHERE c.id = customer_id AND c."isActive" = true;
          
          RETURN result;
        END;
        $$ LANGUAGE plpgsql;

        -- Helper function ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ sales invoice ÿ®ŸÄ ID
        CREATE OR REPLACE FUNCTION get_sales_invoice_by_id(invoice_id UUID)
        RETURNS JSON AS $$
        DECLARE
          result JSON;
        BEGIN
          SELECT json_build_object(
            'id', si.id,
            'invoiceNumber', si."invoiceNumber",
            'invoiceDate', si."invoiceDate",
            'dueDate', si."dueDate",
            'totalAmount', si."totalAmount",
            'status', si.status::text,
            'paymentStatus', si."paymentStatus"::text,
            'salesPerson', si."salesPerson",
            'salesChannel', si."salesChannel",
            'notes', si.notes,
            'customer', json_build_object(
              'id', c.id,
              'code', c.code,
              'name', c.name,
              'phone', c.phone,
              'email', c.email
            )
          ) INTO result
          FROM sales_invoices si
          LEFT JOIN customers c ON si."customerId" = c.id
          WHERE si.id = invoice_id AND si."isActive" = true;
          
          RETURN result;
        END;
        $$ LANGUAGE plpgsql;
      `;
      
      await sequelize.query(helperFunctions);
      console.log('‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° helper functions');
      
    } catch (error) {
      console.log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° helper functions: ${error.message}`);
    }

    // 5. ÿßÿÆÿ™ÿ®ÿßÿ± ÿ¥ÿßŸÖŸÑ ŸÑŸÑŸÄ functions ÿßŸÑÿ¨ÿØŸäÿØÿ©
    console.log('\nüß™ ÿßÿÆÿ™ÿ®ÿßÿ± ÿ¥ÿßŸÖŸÑ ŸÑŸÑŸÄ functions ÿßŸÑÿ¨ÿØŸäÿØÿ©...');
    
    try {
      // ÿßÿÆÿ™ÿ®ÿßÿ± sales summary
      const summaryTest = await sequelize.query(`
        SELECT get_sales_summary() as summary
      `, { type: sequelize.QueryTypes.SELECT });
      console.log('‚úÖ get_sales_summary ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠');
      
      // ÿßÿÆÿ™ÿ®ÿßÿ± sales invoices
      const invoicesTest = await sequelize.query(`
        SELECT get_sales_invoices_fixed(1, 3) as invoices
      `, { type: sequelize.QueryTypes.SELECT });
      console.log('‚úÖ get_sales_invoices_fixed ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠');
      
      // ÿßÿÆÿ™ÿ®ÿßÿ± customers
      const customersTest = await sequelize.query(`
        SELECT get_customers_list_fixed(1, 3) as customers
      `, { type: sequelize.QueryTypes.SELECT });
      console.log('‚úÖ get_customers_list_fixed ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠');
      
      // ÿßÿÆÿ™ÿ®ÿßÿ± dashboard view
      const dashboardTest = await sequelize.query(`
        SELECT * FROM sales_dashboard_view
      `, { type: sequelize.QueryTypes.SELECT });
      console.log('‚úÖ sales_dashboard_view ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠');
      
    } catch (error) {
      console.log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑÿ¥ÿßŸÖŸÑ: ${error.message}`);
    }

    console.log('\nüéâ ÿ™ŸÖ ÿ•ÿµŸÑÿßÿ≠ ÿ¨ŸÖŸäÿπ ŸÖÿ¥ÿßŸÉŸÑ enum ÿ®ŸÜÿ¨ÿßÿ≠!');
    console.log('\nüìã ÿßŸÑŸÖŸÑÿÆÿµ ÿßŸÑŸÜŸáÿßÿ¶Ÿä:');
    console.log('  ‚úÖ get_sales_summary() - ŸÖŸÑÿÆÿµ ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™');
    console.log('  ‚úÖ get_sales_invoices_fixed() - ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÅŸàÿßÿ™Ÿäÿ± (ŸÖÿπ enum casting)');
    console.log('  ‚úÖ get_customers_list_fixed() - ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿπŸÖŸÑÿßÿ° (ŸÖÿπ enum casting)');
    console.log('  ‚úÖ get_customer_by_id() - ÿπŸÖŸäŸÑ Ÿàÿßÿ≠ÿØ');
    console.log('  ‚úÖ get_sales_invoice_by_id() - ŸÅÿßÿ™Ÿàÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©');
    console.log('  ‚úÖ sales_dashboard_view - ÿπÿ±ÿ∂ ÿ¥ÿßŸÖŸÑ ŸÑŸÑŸÖÿ®Ÿäÿπÿßÿ™');
    console.log('\nüí° ÿ¨ŸÖŸäÿπ ÿßŸÑŸÄ functions ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÅŸä APIs!');
    
  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿµŸÑÿßÿ≠ enum:', error.message);
    console.error('üìã ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£:', error);
  } finally {
    await sequelize.close();
  }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ•ÿµŸÑÿßÿ≠
fixEnumIssues();
